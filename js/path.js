//var pathIds = [];  var pathIds = [{"pId" : 1000147, "hhId" : 1000029}];var allPathLayerGeoms = [];var pathLayerGeoms = [];var pathLayerAtts = [];function loadWholePath(nextStep){	allPathLayerGeoms = [];	pathLayerGeoms = [];	pathLayerAtts = [];	for(var i=0; i<pathIds.length; i++){		registerActiveLoad("loadPathGeoms_"+pathIds[i].hhId+"_"+pathIds[i].pId);		d3.json(createPathLayerUrl(pathIds[i].hhId, pathIds[i].pId), 				function(d){					allPathLayerGeoms = allPathLayerGeoms.concat(d.geometries);					pathLayerAtts = pathLayerAtts.concat(d.attributes);					for(var i=0; i<d.geometries.length; i++){						if(d.geometries[i].azimuth == azimuth && d.geometries[i].elevation == elevation){							pathLayerGeoms = pathLayerGeoms.concat(d.geometries[i].segments);							break;						}					}					unregisterActiveLoad("loadPathGeoms_"+d.hh_id+"_"+d.p_id);					nextStep();				});	}}registeredLoaders.push(loadWholePath);/** ** D3-Draw precedures **//* *  */var createPathLayerFunction = d3.svg.line()	.x(function(d) { 		return d[0]; })	.y(function(d) { 		return d[1]; })	.interpolate("linear");/* *  */function showSegmentTooltip(segmentId, d3line){		var segmentAtts = null;	for(var i=0; i<pathLayerAtts.length; i++){		if(segmentId == pathLayerAtts[i].id){			segmentAtts = pathLayerAtts[i];			break;		} 	}		//console.log("segmentAtts: ",segmentAtts);		var isActivity = (segmentAtts.activity)?true:false; 	var isMovement = (segmentAtts.mode)?true:false;	if(!isActivity && !isMovement){		return;	}		var xPosition = d3.mouse(d3.select('body').node())[0]+15;	var yPosition = d3.mouse(d3.select('body').node())[1]+15;		var tt = d3.select("#tooltip");		tt.style("left", xPosition + "px")	  .style("top", yPosition + "px");			d3.select(d3line).style("stroke", "yellow")					 .style("stroke-width", 8);	if(isActivity){		tt.append("p")		  .append("strong")		  .style("display","inline-block")		  .style("margin", "0 0 5px 0")		  .text(LEGEND_DATA.labelMap.layer_possibilities[segmentAtts.activity_type].de);		if(segmentAtts.activity != -1){			tt.append("p")			  .html(LEGEND_DATA.labelMap.layer_activities[segmentAtts.activity].de);		}		addBar(tt, segmentAtts, "activity");	}else if(isMovement){		tt.append("p")		  .append("strong")		  .style("display","inline-block")		  .style("margin", "0 0 5px 0")		  .text(LEGEND_DATA.labelMap.layer_modes[segmentAtts.mode].de);		var distance = segmentAtts.distance;		if(distance < 100){			distance = "< 100m";		}else if(distance > 1000){			distance = (distance/1000).toFixed(1) + "km"; 		}else{			distance = ((distance/100).toFixed(0) * 100) + "m";		}		tt.append("p").text("Strecke "+distance);		addBar(tt, segmentAtts, "movement");	}	//Show the tooltip	tt.classed("hidden", false);}/* *  */function addBar(container, segmentAtts, type){		clockMargin = 15;	var width = 200;	var barHeight = 10;	var von = segmentAtts.von_min;	var dauer = segmentAtts.dauer_min;	var bis = segmentAtts.bis_min;	var unbekannt = segmentAtts.unbekannt_min || 0;	var max = 60*24;		/* text */	if(dauer > 0){		container.append("p")			 .style("text-align","left")			 .style("margin","5px 0")			 .text("von "+segmentAtts.von+" bis "+segmentAtts.bis+" ("+segmentAtts.dauer+")");	}	if(unbekannt > 0){		container.append("p")				 .style("text-align","left")				 .style("margin","5px 0")				 .text("bis "+(segmentAtts.bis_unbekannt)+" unbekannt"+" ("+segmentAtts.dauer+")");	}		/* svg */	var svg = container.append("svg")					 	.attr("width",width+clockMargin*2)					 	.attr("height",50);		svg = svg.append("g").attr("transform","translate("+clockMargin+","+clockMargin+")")		/* main rect */	svg.append("line")		.attr("x1",0)		.attr("y1",barHeight/2)		.attr("x2",width)		.attr("y2",barHeight/2)		.style("fill","white")		.style("stroke","black")		.style("stroke-width",2);	/* ticks */	var stepSize = (24/4)	for(var i=0; i<=24; i+=stepSize){		svg.append("line")			.attr("x1", (width / 24) * i)			.attr("y1", barHeight/2)			.attr("x2", (width / 24) * i)			.attr("y2", barHeight/2+10)			.style("stroke","black");		svg.append("text")		   .attr("x", (width / 24) * i)		   .attr("y", barHeight/2+22)		   .attr("text-anchor","middle")		   .style("font-size","8pt")		   .style("stroke-width",2)		   .text(i+":00");			}		var color = "black";	if(type == "activity"){		color = LEGEND_DATA.colorMap.layer_possibilities[segmentAtts.activity_type];		//console.log("ACTIVITY: type="+segmentAtts.activity_type+" color="+color);	}else if(type == "movement"){		color = LEGEND_DATA.colorMap.layer_modes[segmentAtts.mode];		//console.log("MOVEMENT: mode="+segmentAtts.mode+" color="+color);	}		var unknownX = (width / (24*60)) * von;	var unknownWidth = (width / (24*60)) * dauer + (width / (24*60)) * unbekannt;	svg.append("rect")	.attr("x",unknownX )	.attr("y",0)	.attr("width", unknownWidth )	.attr("height",barHeight )	.style("fill", "white")	.style("stroke", color)	.style("stroke-width", 2);		var activityX = (width / (24*60)) * von;	var activityWidth = (width / (24*60)) * dauer;	svg.append("rect")		.attr("x",activityX)		.attr("y",0)		.attr("width", activityWidth )		.attr("height",barHeight )		.style("fill", color)		.style("stroke", color)		.style("stroke-width", 2);}/* *  */function hideSegmentTooltip(d3line){    d3.select(d3line).style("stroke", "white")					 .style("stroke-width", 5);    d3.select("#tooltip").classed("hidden", true);    d3.selectAll("#tooltip *").remove();}/* *  */function getSegmentColor(i){	if(pathLayerAtts[i].dummy == "true"){		return "silver";	}else if(pathLayerAtts[i].mode){		return LEGEND_DATA.colorMap.layer_modes[pathLayerAtts[i].mode];		return "white";	}else if(pathLayerAtts[i].activity){		return LEGEND_DATA.colorMap.layer_possibilities[pathLayerAtts[i].activity_type];		return "white";	}	return "yellow";}/* *  */function getSegmentOutlineColor(i){	if(pathLayerAtts[i].dummy == "true"){		return "silver";	}else if(pathLayerAtts[i].mode){		return "white"		return LEGEND_DATA.colorMap.layer_modes[pathLayerAtts[i].mode];	}else if(pathLayerAtts[i].activity){		return "white";		return LEGEND_DATA.colorMap.layer_possibilities[pathLayerAtts[i].activity_type];	}	return "yellow";}/* *  */function getSegmentLinecap(segmentId){	var segmentAtts = null;	for(var i=0; i<pathLayerAtts.length; i++){		if(segmentId == pathLayerAtts[i].id){			segmentAtts = pathLayerAtts[i];			break;		} 	}	if(segmentAtts.dummy){		return "butt";	}	return "round";}function getSegmentDasharray(i){	//return "0";	if(pathLayerAtts[i].mode){		return "3,4";	}else if(pathLayerAtts[i].activity){		return "0";	}	return "0";}function getSegmentOutlineWidth(segmentId){	return 5;}function getSegmentWidth(segmentId){	return 3}/* *  */function drawPaths(){	defPaths();	sortPaths();	usePaths();}registeredDrawers.push(drawPaths);/* *  */function defPaths(){	console.log("defPaths!");	PATH_DEFS_SVG.selectAll("path")		.data(pathLayerGeoms, function(d, i){ return d.id; })		.enter()		.append("path")		.attr("id", function(d){ return "path_"+d.id })	    .attr("d", function(d){ return createPathLayerFunction(d.coordinates);})}/* *   */function usePaths(){	PATH_SVG.selectAll("use").remove();	/* Possibility Outlines */	for(var i=0; i<pathLayerGeoms.length; i++){				if(pathLayerAtts[i].dummy){			PATH_SVG.append("use")			.attr("xlink:href", function(){ return "#path_"+pathLayerGeoms[i].id })			.style("stroke", "black")			.style("stroke-width", .5);		}else{						// OUTLINE			PATH_SVG.append("use")				.attr("xlink:href", function(){ return "#path_"+pathLayerGeoms[i].id })				.style("stroke", function(d){ return getSegmentOutlineColor(i)})				.style("stroke-width", function(d){ return getSegmentOutlineWidth(i)})				.style("stroke-linecap", function(){					var href = d3.select(this).attr("xlink:href");					var segmentId = href.substr("#path_".length);					return getSegmentLinecap(segmentId);				})				.style("fill", "none")				.on("mouseover", function(){						var href = d3.select(this).attr("xlink:href");						var segmentId = href.substr("#path_".length);						showSegmentTooltip(segmentId, this);				})				.on("mouseout", function(){						hideSegmentTooltip(this);				});							// FILL			PATH_SVG.append("use")				.attr("xlink:href", function(d){ return "#path_"+pathLayerGeoms[i].id })				.style("stroke", function(d){ return getSegmentColor(i)})				.style("stroke-width", function(d){ return getSegmentWidth(i)})				.style("stroke-linecap", function(){					var href = d3.select(this).attr("xlink:href");					var segmentId = href.substr("#path_".length);					return getSegmentLinecap(segmentId);				})				.style("fill", "none")				.style("stroke-dasharray", function(d){					return getSegmentDasharray(i);				})				.style("pointer-events", "none");		}	}}/* *  */function transitPaths(){	sortPaths();	usePaths();	PATH_SVG.selectAll("path")		.data(pathLayerGeoms, function(d, i){ return d.id; })		.transition()	    .attr("d", function(d){			return createPathLayerFunction(d.coordinates);		});}registeredTransitioners.push(transitPaths);function getCurrentSpaceTimePath(){	for(var i=0; i<pathLayers.length; i++){		if(pathLayers[i].e == elevation				&& pathLayers[i].a == azimuth){			return pathLayers[i];		}	}}/** ** SORT  **//** * LINE INTERSECTON! */function checkLineIntersection(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point    var denominator, a, b, numerator1, numerator2, result = {        x: null,        y: null,        onLine1: false,        onLine2: false    };    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));    if (denominator == 0) {        return result;    }    a = line1StartY - line2StartY;    b = line1StartX - line2StartX;    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);    a = numerator1 / denominator;    b = numerator2 / denominator;    // if we cast these lines infinitely in both directions, they intersect here:    result.x = line1StartX + (a * (line1EndX - line1StartX));    result.y = line1StartY + (a * (line1EndY - line1StartY));    /*        // it is worth noting that this should be the same as:        x = line2StartX + (b * (line2EndX - line2StartX));        y = line2StartX + (b * (line2EndY - line2StartY));        */    // if line1 is a segment and line2 is infinite, they intersect if:    if (a > 0 && a < 1) {        result.onLine1 = true;    }    // if line2 is a segment and line1 is infinite, they intersect if:    if (b > 0 && b < 1) {        result.onLine2 = true;    }    // if line1 and line2 are segments, they intersect if both of the above are true    return result;}/* * Sort */function sortPaths(){	pathComapres = compareSegments();	sortPathGeomSegments(pathComapres);	sortSyncronizeAtts();}registeredSorts.push(sortPaths);/* * Vergleicht Segment für Segment auf Verschneidungen * und berechnet die jeweilige Z-Koordinate der Segmente * am Schnittpunkt */function compareSegments(){		var segmentCompares = [];		for(var i=0; i<pathLayerGeoms.length; i++){		var a = pathLayerGeoms[i];		for(var j=0; j < pathLayerGeoms.length; j++){			var b = pathLayerGeoms[j]; 			var x = checkLineIntersection(a.coordinates[0][0],a.coordinates[0][1],										  a.coordinates[1][0],a.coordinates[1][1],										  b.coordinates[0][0],b.coordinates[0][1],										  b.coordinates[1][0],b.coordinates[1][1]);									if(x.onLine1 && x.onLine2){								//immer mit Y, da X gleich identisch sein koennten!				var yArel = (a.coordinates[0][1] - x.y) / (a.coordinates[0][1] - a.coordinates[1][1]);				var zA = a.coordinates[0][2] - ((a.coordinates[0][2] - a.coordinates[1][2]) * yArel);								var yBrel = (b.coordinates[0][1] - x.y) / (b.coordinates[0][1] - b.coordinates[1][1]);				var zB = b.coordinates[0][2] - ((b.coordinates[0][2] - b.coordinates[1][2]) * yBrel);				segmentCompares.push({"aId":a.id,"zA":zA,"bId":b.id,"zB":zB});							}else{				//segmentCompares.push({"aId":a.id,"aZ":zA,"bId":b.id,"bZ":zB});			}		}	}	return segmentCompares;}/* * sortSegments */function sortPathGeomSegments(segmentCompares){	/* Phase 1:	 * alle ohne Verschnitt nach vorn, bzw. alle mit Verschnitt nach hinten*/	pathLayerGeoms.sort(function(a, b){		aAtt = null;		for(var i=0; i<pathLayerAtts.length; i++){			if(a.id == pathLayerAtts[i].id){				aAtt = pathLayerAtts[i];				break;			}		}		bAtt = null;		for(var i=0; i<pathLayerAtts.length; i++){			if(b.id == pathLayerAtts[i].id){				bAtt = pathLayerAtts[i];				break;			}		}				if(bAtt.dummy == "true"){			return +1;		}		return 0;	});		pathLayerGeoms.sort(function(a, b){		zA = null;		zB = null;				for(var i=0; i<segmentCompares.length; i++){			if(a.id == segmentCompares[i].aId){				zA = segmentCompares[i].zA;			}else if(a.id == segmentCompares[i].bId){				zB= segmentCompares[i].zB;			}		}		if(zA != null){			return +1;		}		return 0;				//nur test ob B eine Überschneidung besitzt		if(zA != null && zB == null){			return -1;		}		if(zA == null && zB != null){			return +1;		}		return 0;	});		/* Phase 3:	 * alle nur die Verschneidungen sortieren	 * -> die vorderen nach hinten */		//for(var step=0; step<pathIds.length; step++){		pathLayerGeoms.sort(function(a, b){			zA = null;			zB = null;						for(var i=0; i<segmentCompares.length; i++){				if(a.id == segmentCompares[i].aId && b.id == segmentCompares[i].bId){					//konkreter test!					zA = segmentCompares[i].zA;					zB = segmentCompares[i].zB;					if(zA > zB){						return -1;					}else{						return +1;					}				}			}			return 0;		});	}/* * Überträgt die Reihenfolge der pathLayerGeoms auf pathLayerAtts  * (später wichtig für Signatur und Tooltip) */function sortSyncronizeAtts(){	for(var i=0; i<pathLayerGeoms.length; i++){		currentSegmentId = pathLayerGeoms[i].id;				currentAttElement = null;		var j=0;		for(; j<pathLayerAtts.length;j++){			if(pathLayerAtts[j].id == currentSegmentId){				break;			}		}		var tempAtt = pathLayerAtts[i];		pathLayerAtts[i] = pathLayerAtts[j];		pathLayerAtts[j] = tempAtt;	}		var idString = "";	for(var i=0; i < pathLayerAtts.length; i++){		idString += " "+pathLayerAtts[i].id;	}}function getIdList(pathArray){	var idString = "";	for(var i=0; i < pathArray.length; i++){		idString += " "+pathArray[i].id;	}	return idString;}